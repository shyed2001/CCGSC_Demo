<%
// File Path: prime_distributed_projectPrlCc1B V5(10K)/public/worker.js
// Filename: worker.js

// ## 1. Module Import and Initialization ##
// =========================================

// What: This line imports the default export from the 'prime_library.js' script.
// How: It uses the ES6 module 'import' syntax. The 'wasmFactory' name is an alias for the default export.
// Why: The 'prime_library.js' file is a JavaScript "glue" file generated by Emscripten (a C++ to WebAssembly compiler).
//      This 'wasmFactory' function is responsible for asynchronously loading, compiling, and instantiating the
//      WebAssembly (.wasm) binary file, which contains our compiled C++ code. We need this to run the high-performance prime counting logic.
import wasmFactory from './prime_library.js';

// What: This line retrieves the HTML element from the webpage that has the ID 'status'.
// How: It uses the standard browser Document Object Model (DOM) API function `document.getElementById()`.
// Why: We need a reference to this element so we can update its text content to provide real-time feedback to the user
//      about the worker's current state (e.g., "Connecting", "Computing", "Error").
const statusDiv = document.getElementById('status');

// What: This declares a variable named 'wasmModule' and initializes it to 'null'.
// How: 'let' is used because the value of this variable will be reassigned later. It starts as 'null' to indicate that the module has not been loaded yet.
// Why: This variable will act as a cache for the initialized WebAssembly module. Loading and compiling WASM is an expensive operation.
//      By storing the module instance in this variable after the first load, we can reuse it for all subsequent tasks without reloading, significantly improving performance.
let wasmModule = null;


// ## 2. WebSocket Connection Setup ##
// ==================================

// What: This line immediately updates the status message on the webpage.
// Why: To inform the user that the first step, attempting to connect to the server, is in progress.
statusDiv.textContent = 'Connecting to coordinator...';

// What: This line creates a new WebSocket client instance and initiates a connection to a server.
// How: It calls the `WebSocket` constructor, passing the URL of the WebSocket server endpoint.
//      - 'wss://' specifies the protocol, which is "WebSocket Secure" (the encrypted version, like HTTPS).
//      - 'ccgsc-demo.digitalbd.org/ws' is the address of the server and the specific path for WebSocket connections.
// Why: A WebSocket provides a persistent, full-duplex (two-way) communication channel between this client (the worker) and the server.
//      This is far more efficient than traditional HTTP requests for this use case because it allows the server to "push" tasks to the worker
//      as soon as they are available, without the worker needing to constantly ask ("poll") for new work.
const socket = new WebSocket('wss://ccgsc-demo.digitalbd.org/ws'); // Your secure server URL


// ## 3. WebSocket Event Handlers ##
// ================================
// The following code blocks are event-driven. They define what the worker should do in response to specific network events.

// ### 3.1. On Connection Open ###
// -------------------------------
// What: This defines the function that will be executed exactly once when the WebSocket connection is successfully established.
// How: `socket.onopen` is an event handler property. We assign an arrow function `() => { ... }` to it.
// Control Flow: The browser's networking engine triggers this 'open' event, causing our function to run.
socket.onopen = () => {
    // What: Update the status message on the page.
    // Why: To give the user a clear confirmation that the connection to the coordinator server is live and the worker is ready for instructions.
    statusDiv.textContent = '✅ Connected. Awaiting tasks.';

    // What: Sends a message to the server.
    // How: It creates a JavaScript object `{ type: 'registerWorker' }`, converts it into a JSON string using `JSON.stringify()`,
    //      and then sends that string over the WebSocket connection using `socket.send()`.
    // Data Flow: This is the first piece of data the client sends to the server.
    // Why: This message acts as a registration. It tells the server, "A new worker is online and available to receive tasks." The server can then add this worker to its pool of available clients.
    socket.send(JSON.stringify({ type: 'registerWorker' }));
};


// ### 3.2. On Message Received ###
// --------------------------------
// What: This defines the function that will execute every time a new message arrives from the server.
// How: `socket.onmessage` is the event handler for incoming data. We assign an 'async' arrow function to it.
//      - The function is marked 'async' because the process of loading the WASM module inside it is asynchronous.
//        This allows us to use the 'await' keyword for cleaner handling of that operation.
// Control Flow: This function is the heart of the worker's logic. It's triggered by the server sending data.
socket.onmessage = async (event) => {
    // What: Parses the incoming message data.
    // How: The `event` object contains the message data in its `data` property, which is a JSON string. `JSON.parse()` deserializes this string back into a JavaScript object.
    // Data Flow: Data flows from the server, through the WebSocket, into `event.data`, and is then converted into a usable 'data' object.
    // Why: We need to convert the string representation of the data back into an object to easily access its properties like `type` and `task`.
    const data = JSON.parse(event.data);

    // What: This is a "guard clause" that checks the `type` property of the incoming message.
    // Control Flow: If the message type is not 'task', the function immediately stops execution (`return;`) and waits for the next message.
    // Why: This ensures the worker only tries to perform computations on messages that are explicitly designated as tasks. It makes the system more robust, as the server could potentially send other message types (e.g., status checks, announcements) that should be ignored by this logic.
    if (data.type !== 'task') return;

    // What: Extracts the 'task' object from the main 'data' object.
    // How: It uses ES6 object destructuring, which is a concise way of writing `const task = data.task;`.
    // Data: The 'task' object contains the details of the work to be done, such as the start and end of the number range.
    const { task } = data;

    // What: Updates the status message to show which specific task is being worked on.
    // How: It uses a template literal (the backticks ``) to easily embed the `task.taskId` into the string.
    // Why: Provides granular feedback to the user, which is helpful if multiple tasks are being processed in sequence.
    statusDiv.textContent = `Computing task #${task.taskId}...`;

    // What: This block attempts to execute the core task logic and gracefully handles any errors that might occur.
    // Control Flow: Code inside `try` is executed. If at any point an error is thrown, execution immediately jumps to the `catch (error)` block.
    // Why: This is crucial for resilience. A failure in one task (e.g., a bug in the C++ code, invalid data from the server) should not crash the entire worker. It allows us to catch the error, report it, and continue to wait for new tasks.
    try {
        // What: Checks if the `wasmModule` has been loaded yet.
        // Control Flow: The code inside this 'if' block will only run on the very first task this worker receives.
        // Why: This is the caching logic. We only want to incur the cost of loading and compiling the WebAssembly module once.
        if (!wasmModule) {
            // What: Updates the UI to inform the user about the one-time module loading process.
            statusDiv.textContent = `Loading WASM Module for task #${task.taskId}...`;
            
            // What: Calls the factory function to initialize the WebAssembly module.
            // How: The 'await' keyword pauses the execution of this `onmessage` function until the `wasmFactory()` promise resolves.
            //      Once the module is ready, it's assigned to our cached `wasmModule` variable.
            // Why: This ensures that we do not proceed to call a C++ function before the module containing it is fully loaded and ready.
            wasmModule = await wasmFactory();
        }
        
        // What: Dynamically creates the name of the C++ function to be called based on the task ID.
        // How: String interpolation is used to combine a prefix "worker_func_" with the unique `task.taskId`.
        // Why: This design suggests a flexible system where each task could potentially map to a different exported function in the C++ code.
        const functionToCall = `worker_func_${task.taskId}`;
        
        // What: Updates the UI to show that the computation is now being passed to the C++ code.
        statusDiv.textContent = `Executing C++ for task #${task.taskId}...`;
        
        // What: Converts the numeric range boundaries from the standard JavaScript string/number format to the BigInt format.
        // How: It calls the `BigInt()` constructor on the `start` and `end` properties of the task object.
        // Why: Standard JavaScript numbers have a limited precision (`Number.MAX_SAFE_INTEGER`). For serious number theory problems like prime counting over vast ranges,
        //      we need arbitrary-precision integers. `BigInt` provides this capability. The numbers are sent as strings in JSON to avoid any precision loss during transit.
        const startBigInt = BigInt(task.start);
        const endBigInt = BigInt(task.end);

        // What: This is the core of the work. It calls a function within the compiled C++ module from JavaScript.
        // How: It uses `ccall`, a helper function provided by the Emscripten "glue" code.
        const primeCount = wasmModule.ccall(
            functionToCall,       // 1. Name of the C++ function to execute.
            'bigint',             // 2. The expected return type. We tell Emscripten the C++ function will return a value that should be treated as a BigInt in JavaScript.
            ['bigint', 'bigint'], // 3. An array of strings describing the types of the arguments we are providing. Both are BigInts.
            [startBigInt, endBigInt] // 4. An array containing the actual argument values to pass to the C++ function.
        );
        
        // What: Sends the computed result back to the server.
        // How: It constructs a result object, converts the `primeCount` BigInt back to a string using `.toString()` for safe JSON serialization, and sends the JSON string.
        // Data Flow: The result flows from the worker back to the coordinator server.
        // Why: To report the successful completion of the task. The server can then aggregate this result with others.
        socket.send(JSON.stringify({ type: 'result', taskId: task.taskId, count: primeCount.toString() }));
        
        // What: Updates the UI to show the task is complete and the worker is idle again.
        statusDiv.textContent = '✅ Task complete. Awaiting next task.';

    } catch (error) {
        // What: This block runs only if an error occurred in the `try` block.
        // Why: For robust error handling and reporting.
        
        // What: Logs the detailed error object to the browser's developer console.
        // Why: This is essential for debugging purposes so a developer can see the exact error message and stack trace.
        console.error(`Error executing task ${task.taskId}:`, error);
        
        // What: Updates the UI to clearly inform the user that the task failed.
        statusDiv.textContent = `❌ Error on task #${task.taskId}. Reporting to server.`;
        
        // What: Sends an error message to the server.
        // Data Flow: Sends failure information back to the coordinator.
        // Why: This allows the server to know that the task failed. The server's logic can then decide whether to retry the task or reassign it to a different worker.
        socket.send(JSON.stringify({ type: 'error', taskId: task.taskId, message: error.message }));
    }
};


// ### 3.3. On Connection Close ###
// --------------------------------
// What: Defines the function that will execute if the WebSocket connection is terminated for any reason.
// Control Flow: This can be triggered by the server closing the connection, a network failure, or the browser tab being closed.
socket.onclose = () => {
    // What: Updates the status UI.
    // Why: To inform the user that the connection has been lost and to provide instructions on how to reconnect (by refreshing the page, which restarts the script).
    statusDiv.textContent = '❌ Disconnected from coordinator. Please refresh the page to reconnect.';
};